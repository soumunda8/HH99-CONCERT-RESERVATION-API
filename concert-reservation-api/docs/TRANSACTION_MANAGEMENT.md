# TRANSACTION-MANAGEMENT.md

## 개요

서비스의 규모가 확장되어 마이크로서비스 아키텍처(MSA)로 전환할 경우, 개별 서비스와 데이터베이스가 분리되면서 서비스 간의 트랜잭션 처리가 어려워집니다. 특히, 다른 서비스에 대한 의존성을 줄이기 위해 Kafka와 같은 이벤트 핸들러를 활용하여 서비스 간 로직 호출을 관리하면서 각 서비스의 데이터베이스를 완전히 독립적으로 유지하는 방식이 필요합니다. 이런 환경에서는 데이터베이스 간 트랜잭션을 관리하기 위한 **보상 트랜잭션**과 **Saga 패턴**이 중요해집니다.

## 현재 기능의 트랜잭션 범위

현재 개발한 기능(예: 결제 기능)의 트랜잭션 범위는 다음과 같이 설정됩니다:

1. **결제 정보 Insert**: 결제 요청이 들어오면 결제 정보를 데이터베이스에 저장합니다.
2. **예약 상태 Update**: 결제가 완료되면 예약 상태를 업데이트하여 예약이 확정되었음을 표시합니다.
3. **포인트 차감 Insert**: 결제와 동시에 포인트 차감 내역을 기록하여 사용자의 포인트를 갱신합니다.

위의 작업은 하나의 트랜잭션 내에서 순차적으로 이루어지며, 만약 3단계에서 오류가 발생할 경우, 앞의 작업들(결제 정보 및 예약 상태)을 초기 상태로 되돌려야 합니다. 이러한 트랜잭션 관리 방식은 단일 데이터베이스 환경에서는 비교적 쉽게 처리할 수 있지만, 서비스가 분리된 MSA 구조에서는 트랜잭션 범위가 각기 다른 서비스로 나뉘기 때문에 일관된 트랜잭션 처리가 어렵습니다.

## 서비스 확장 시 발생하는 문제

서비스가 MSA 구조로 확장됨에 따라, 다음과 같은 문제점이 발생할 수 있습니다:

- **데이터 일관성 문제**: 각 서비스가 개별적으로 데이터를 관리할 경우, 특정 트랜잭션 중간에 오류가 발생하면 데이터 간 불일치가 발생할 수 있습니다.
- **단일 트랜잭션 불가능**: 서비스가 분리되면서 여러 서비스에 걸쳐 하나의 트랜잭션을 관리하는 것이 불가능해집니다.
- **복잡한 오류 처리**: 중간에 오류가 발생했을 때, 각 서비스에 걸친 데이터 복구 및 되돌리기 작업이 매우 복잡해질 수 있습니다.

## 해결 방안

이러한 문제를 해결하기 위해 다음과 같은 방안을 적용할 수 있습니다:

### 1. 보상 트랜잭션 (Compensating Transaction)

보상 트랜잭션은 개별 트랜잭션 실패 시 이전 단계의 작업을 취소하여 데이터 일관성을 유지하는 방식입니다. 예를 들어, 결제 포인트 차감에서 오류가 발생했을 경우 다음과 같은 보상 작업을 수행합니다:

- **결제 정보 삭제**: 포인트 차감 실패 시 결제 정보를 삭제하여 결제 내역을 취소합니다.
- **예약 상태 복구**: 예약 상태를 이전 상태로 되돌려 예약을 확정되지 않은 상태로 복구합니다.

이 방식은 트랜잭션 실패 시 데이터의 일관성을 유지할 수 있지만, 서비스가 많아질수록 관리가 복잡해질 수 있습니다.

### 2. Saga 패턴

Saga 패턴은 분산된 트랜잭션 환경에서 트랜잭션 관리 문제를 해결하는 방식으로, 보상 트랜잭션을 체계적으로 관리할 수 있도록 도와줍니다. Saga 패턴에는 두 가지 방식이 있습니다.

#### Choreography-Based Saga

각 서비스가 이벤트를 통해 다음 단계로 넘어가며, 오류 발생 시 보상 트랜잭션을 통해 이전 단계를 되돌립니다. 예를 들어, 결제 완료 시 예약 서비스가 상태를 업데이트하고, 오류 발생 시 이전 단계를 롤백합니다.

**장점**:
- 분산된 구조로, 서비스가 독립적으로 이벤트를 처리합니다.
- 중앙 관리가 필요 없어 변경에 유연합니다.

**단점**:
- 서비스가 많아지면 이벤트 흐름이 복잡해질 수 있습니다.
- 오류 추적이 어렵고, 전체 흐름을 파악하기가 까다롭습니다.

#### Orchestration-Based Saga

중앙에서 트랜잭션을 관리하는 오케스트레이터가 각 서비스에 순서를 지시하고, 오류 발생 시 보상 작업을 관리합니다. 중앙 집중식으로 트랜잭션을 관리하기 때문에 로직을 추적하기 쉽습니다.

**장점**:
- 중앙 집중식 관리로 흐름을 쉽게 파악할 수 있습니다.
- 오류 관리와 보상 작업이 비교적 단순합니다.

**단점**:
- 중앙 오케스트레이터에 의존성이 생겨 단일 장애 지점이 될 수 있습니다.
- 오케스트레이터 로직이 복잡해질 가능성이 있습니다.

## 결론

서비스의 규모가 확장됨에 따라 트랜잭션 관리는 더욱 복잡해지며, MSA 구조에서는 단일 데이터베이스 트랜잭션이 어려워 보상 트랜잭션과 Saga 패턴이 필수적입니다. 트랜잭션 처리 방식을 선택할 때 각 서비스의 특성과 데이터 일관성 요구 사항을 고려하여 Choreography-based Saga와 Orchestration-based Saga 중 적절한 방식을 선택해야 합니다.

- **Choreography-based Saga**는 자율성을 중시하는 소규모 서비스에 적합하며, 이벤트 흐름 기반으로 분산 환경에서 관리됩니다.
- **Orchestration-based Saga**는 중앙 관리와 일관성 유지가 중요한 경우에 적합하며, 오케스트레이터를 통해 트랜잭션 흐름을 제어합니다.

이러한 구조를 통해 서비스 간 독립성을 유지하면서도 신뢰성 있는 트랜잭션 관리 방안을 설계할 수 있습니다.
